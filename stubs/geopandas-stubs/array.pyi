import builtins
from _typeshed import Incomplete, Unused
from collections.abc import Sequence
from typing import Any, Literal, NoReturn, overload
from typing_extensions import Self, TypeAlias, deprecated

import numpy as np
import pandas as pd
from numpy.typing import ArrayLike, DTypeLike, NDArray
from pandas.api.extensions import ExtensionArray, ExtensionDtype
from pyproj import CRS, Transformer
from shapely import Point
from shapely.geometry.base import BaseGeometry

from geopandas.base import _ConvertibleToCRS

_ArrayOrGeom: TypeAlias = GeometryArray | ArrayLike | BaseGeometry
_Origin: TypeAlias = Literal["center", "centroid"] | Point | tuple[float, float] | tuple[float, float, float]

TransformerFromCRS = Transformer.from_crs

class GeometryDtype(ExtensionDtype):
    type = BaseGeometry
    name: str
    na_value: float
    @classmethod
    def construct_from_string(cls, string: str) -> Self: ...
    @classmethod
    def construct_array_type(cls) -> builtins.type[GeometryArray]: ...

def from_shapely(data, crs: _ConvertibleToCRS | None = None) -> GeometryArray: ...
def to_shapely(geoms: GeometryArray) -> NDArray[np.object_]: ...
def from_wkb(data, crs: _ConvertibleToCRS | None = None) -> GeometryArray: ...
@overload
def to_wkb(geoms: GeometryArray, hex: Literal[False] = False, **kwargs) -> NDArray[np.bytes_]: ...
@overload
def to_wkb(geoms: GeometryArray, hex: Literal[True], **kwargs) -> NDArray[np.str_]: ...
def from_wkt(data, crs: _ConvertibleToCRS | None = None) -> GeometryArray: ...
def to_wkt(geoms: GeometryArray, **kwargs) -> NDArray[np.str_]: ...
def points_from_xy(
    x: ArrayLike, y: ArrayLike, z: ArrayLike | None = None, crs: _ConvertibleToCRS | None = None
) -> GeometryArray: ...

class GeometryArray(ExtensionArray):
    def __init__(self, data: GeometryArray | NDArray[np.object_], crs: _ConvertibleToCRS | None = None) -> None: ...
    @property
    @deprecated("Attribute `.data` is deprecated. Use method `to_numpy()` instead.")
    def data(self) -> NDArray[np.object_]: ...
    @property
    def sindex(self): ...
    @property
    def has_sindex(self) -> bool: ...
    @property
    def crs(self) -> CRS | None: ...
    @crs.setter
    def crs(self, value: _ConvertibleToCRS) -> None: ...
    def check_geographic_crs(self, stacklevel: int) -> None: ...
    @property
    def dtype(self) -> GeometryDtype: ...
    def __len__(self) -> int: ...
    def __getitem__(self, idx): ...
    def __setitem__(self, key, value) -> None: ...
    @property
    def is_valid(self) -> NDArray[np.bool_]: ...
    @property
    def is_empty(self) -> NDArray[np.bool_]: ...
    @property
    def is_simple(self) -> NDArray[np.bool_]: ...
    @property
    def is_ring(self) -> NDArray[np.bool_]: ...
    @property
    def is_closed(self) -> NDArray[np.bool_]: ...
    @property
    def has_z(self) -> NDArray[np.bool_]: ...
    @property
    def geom_type(self) -> NDArray[np.int_]: ...
    @property
    def area(self) -> NDArray[np.float_]: ...
    @property
    def length(self) -> NDArray[np.float_]: ...
    @property
    def boundary(self) -> GeometryArray: ...
    @property
    def centroid(self) -> GeometryArray: ...
    def concave_hull(self, ratio: float, allow_holes: bool) -> GeometryArray: ...
    @property
    def convex_hull(self) -> GeometryArray: ...
    def delaunay_triangles(self, tolerance: float, only_edges: bool) -> GeometryArray: ...
    @property
    def envelope(self) -> GeometryArray: ...
    def minimum_rotated_rectangle(self) -> GeometryArray: ...
    @property
    def exterior(self) -> GeometryArray: ...
    def extract_unique_points(self) -> GeometryArray: ...
    def offset_curve(
        self,
        distance: float | ArrayLike,
        quad_segs: int = 8,
        join_style: Literal["round", "bevel", "mitre"] = "round",
        mitre_limit: float = 5.0,
    ) -> GeometryArray: ...
    @property
    def interiors(self) -> NDArray[np.object_]: ...
    def remove_repeated_points(self, tolerance: float | ArrayLike = 0.0) -> GeometryArray: ...
    def representative_point(self) -> GeometryArray: ...
    def minimum_bounding_circle(self) -> GeometryArray: ...
    def minimum_bounding_radius(self) -> NDArray[np.float_]: ...
    def normalize(self) -> GeometryArray: ...
    def make_valid(self) -> GeometryArray: ...
    def reverse(self) -> GeometryArray: ...
    def segmentize(self, max_segment_length: float | ArrayLike) -> GeometryArray: ...
    def covers(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def covered_by(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def contains(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def crosses(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def disjoint(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def geom_equals(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def intersects(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def overlaps(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def touches(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def within(self, other: _ArrayOrGeom) -> NDArray[np.bool_]: ...
    def geom_equals_exact(self, other: _ArrayOrGeom, tolerance: float | ArrayLike) -> NDArray[np.bool_]: ...
    @deprecated("Method `geom_almost_equals` is deprecated. Use `geom_equals_exact` instead.")
    def geom_almost_equals(self, other: _ArrayOrGeom, decimal: float) -> NDArray[np.bool_]: ...
    def clip_by_rect(self, xmin: float, ymin: float, xmax: float, ymax: float) -> GeometryArray: ...
    def difference(self, other: _ArrayOrGeom) -> GeometryArray: ...
    def intersection(self, other: _ArrayOrGeom) -> GeometryArray: ...
    def symmetric_difference(self, other: _ArrayOrGeom) -> GeometryArray: ...
    def union(self, other: _ArrayOrGeom) -> GeometryArray: ...
    def shortest_line(self, other: _ArrayOrGeom) -> GeometryArray: ...
    def distance(self, other: _ArrayOrGeom) -> NDArray[np.float_]: ...
    def hausdorff_distance(self, other: _ArrayOrGeom, **kwargs: Any) -> NDArray[np.float_]: ...
    def frechet_distance(self, other: _ArrayOrGeom, **kwargs) -> NDArray[np.float_]: ...
    def buffer(self, distance: float | ArrayLike, resolution: int = 16, **kwargs) -> GeometryArray: ...
    def interpolate(self, distance, normalized: bool = False) -> GeometryArray: ...
    def simplify(self, tolerance: float | ArrayLike, preserve_topology: bool = True) -> GeometryArray: ...
    def project(self, other: _ArrayOrGeom, normalized: bool = False) -> GeometryArray: ...
    def relate(self, other: _ArrayOrGeom) -> NDArray[np.str_]: ...
    def unary_union(self) -> BaseGeometry: ...
    def affine_transform(self, matrix: Incomplete) -> GeometryArray: ...
    def translate(self, xoff: float = 0.0, yoff: float = 0.0, zoff: float = 0.0) -> GeometryArray: ...
    def rotate(self, angle: float, origin: _Origin = "center", use_radians: bool = False) -> GeometryArray: ...
    def scale(self, xfact: float = 1.0, yfact: float = 1.0, zfact: float = 1.0, origin: _Origin = "center") -> GeometryArray: ...
    def skew(self, xs: float = 0.0, ys: float = 0.0, origin: _Origin = "center", use_radians: bool = False) -> GeometryArray: ...
    def to_crs(self, crs: _ConvertibleToCRS | None = None, epsg: int | None = None) -> GeometryArray: ...
    def estimate_utm_crs(self, datum_name: str = "WGS 84") -> CRS: ...
    @property
    def x(self) -> NDArray[np.float_]: ...
    @property
    def y(self) -> NDArray[np.float_]: ...
    @property
    def z(self) -> NDArray[np.float_]: ...
    @property
    def bounds(self) -> NDArray[np.float_]: ...
    @property
    def total_bounds(self) -> NDArray[np.float_]: ...
    @property
    def size(self) -> int: ...
    @property
    def shape(self) -> tuple[int]: ...
    @property
    def ndim(self) -> int: ...
    def copy(self, *args: Unused, **kwargs: Unused) -> GeometryArray: ...
    def take(
        self, indices: Sequence[int] | NDArray[np.int_], allow_fill: bool = False, fill_value: BaseGeometry | None = None
    ) -> GeometryArray: ...
    def fillna(
        self,
        value: BaseGeometry | GeometryArray | None = None,
        method: Literal["backfill", "bfill", "pad", "ffill"] | None = None,
        limit: int | None = None,
        copy: bool = True,
    ) -> GeometryArray: ...
    def astype(self, dtype: DTypeLike, copy: bool = True) -> GeometryArray | ExtensionArray | NDArray[Any]: ...
    def isna(self) -> NDArray[np.bool_]: ...
    def value_counts(self, dropna: bool = True) -> pd.Series[int]: ...
    def unique(self) -> GeometryArray: ...
    @property
    def nbytes(self) -> int: ...
    def shift(self, periods: int = 1, fill_value: BaseGeometry | None = None) -> GeometryArray: ...
    def argmin(self, skipna: bool = True) -> NoReturn: ...
    def argmax(self, skipna: bool = True) -> NoReturn: ...
    def __array__(self, dtype: Unused | None = None) -> NDArray[np.object_]: ...
    def __eq__(self, other: object) -> NDArray[np.bool_]: ...  # type: ignore[override]
    def __ne__(self, other: object) -> NDArray[np.bool_]: ...  # type: ignore[override]
    def __contains__(self, item: object) -> bool: ...
