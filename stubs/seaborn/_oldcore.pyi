from _typeshed import Incomplete
from collections import UserString
from collections.abc import Generator

from ._decorators import share_init_params_with_map as share_init_params_with_map
from .external.version import Version as Version
from .palettes import QUAL_PALETTES as QUAL_PALETTES, color_palette as color_palette
from .utils import get_color_cycle as get_color_cycle, remove_na as remove_na

class SemanticMapping:
    map_type: Incomplete
    levels: Incomplete
    lookup_table: Incomplete
    plotter: Incomplete
    def __init__(self, plotter) -> None: ...
    def map(cls, plotter, *args, **kwargs): ...
    def __call__(self, key, *args, **kwargs): ...

class HueMapping(SemanticMapping):
    palette: Incomplete
    norm: Incomplete
    cmap: Incomplete
    map_type: Incomplete
    lookup_table: Incomplete
    levels: Incomplete
    def __init__(
        self, plotter, palette: Incomplete | None = ..., order: Incomplete | None = ..., norm: Incomplete | None = ...
    ) -> None: ...
    def infer_map_type(self, palette, norm, input_format, var_type): ...
    def categorical_mapping(self, data, palette, order): ...
    def numeric_mapping(self, data, palette, norm): ...

class SizeMapping(SemanticMapping):
    norm: Incomplete
    map_type: Incomplete
    levels: Incomplete
    sizes: Incomplete
    size_range: Incomplete
    lookup_table: Incomplete
    def __init__(
        self, plotter, sizes: Incomplete | None = ..., order: Incomplete | None = ..., norm: Incomplete | None = ...
    ) -> None: ...
    def infer_map_type(self, norm, sizes, var_type): ...
    def categorical_mapping(self, data, sizes, order): ...
    def numeric_mapping(self, data, sizes, norm): ...

class StyleMapping(SemanticMapping):
    map_type: str
    levels: Incomplete
    lookup_table: Incomplete
    def __init__(
        self, plotter, markers: Incomplete | None = ..., dashes: Incomplete | None = ..., order: Incomplete | None = ...
    ) -> None: ...

class VectorPlotter:
    semantics: Incomplete
    wide_structure: Incomplete
    flat_structure: Incomplete
    def __init__(self, data: Incomplete | None = ..., variables=...) -> None: ...
    @classmethod
    def get_semantics(cls, kwargs, semantics: Incomplete | None = ...): ...
    @property
    def has_xy_data(self): ...
    @property
    def var_levels(self): ...
    input_format: str
    plot_data: Incomplete
    variables: Incomplete
    var_types: Incomplete
    def assign_variables(self, data: Incomplete | None = ..., variables=...): ...
    def iter_data(
        self,
        grouping_vars: Incomplete | None = ...,
        *,
        reverse: bool = ...,
        from_comp_data: bool = ...,
        by_facet: bool = ...,
        allow_empty: bool = ...,
        dropna: bool = ...,
    ) -> Generator[Incomplete, None, None]: ...
    @property
    def comp_data(self): ...
    def scale_native(self, axis, *args, **kwargs) -> None: ...
    def scale_numeric(self, axis, *args, **kwargs) -> None: ...
    def scale_datetime(self, axis, *args, **kwargs) -> None: ...
    def scale_categorical(self, axis, order: Incomplete | None = ..., formatter: Incomplete | None = ...): ...

class VariableType(UserString):
    allowed: Incomplete
    def __init__(self, data) -> None: ...
    def __eq__(self, other): ...

def variable_type(vector, boolean_type: str = ...): ...
def infer_orient(
    x: Incomplete | None = ..., y: Incomplete | None = ..., orient: Incomplete | None = ..., require_numeric: bool = ...
): ...
def unique_dashes(n): ...
def unique_markers(n): ...
def categorical_order(vector, order: Incomplete | None = ...): ...
