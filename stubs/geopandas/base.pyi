from _typeshed import Incomplete
from collections.abc import Iterable
from typing import Any, Literal, Protocol
from typing_extensions import TypeAlias

import numpy as np
import pandas as pd
from numpy.random import BitGenerator, Generator as RandomGenerator, SeedSequence
from numpy.typing import ArrayLike, NDArray
from pyproj import CRS
from shapely.geometry.base import BaseGeometry

from .array import _Origin
from .geoseries import GeoSeries
from .sindex import BaseSpatialIndex

class _SupportsToWkt(Protocol):
    def to_wkt(self) -> str: ...

_ConvertibleToCRS: TypeAlias = str | int | tuple[str, str] | list[str] | dict[str, Any] | _SupportsToWkt

def is_geometry_type(data: object) -> bool: ...

class GeoPandasBase:
    @property
    def area(self) -> pd.Series[float]: ...
    @property
    def crs(self) -> CRS | None: ...
    @crs.setter
    def crs(self, value: _ConvertibleToCRS | None) -> None: ...
    @property
    def geom_type(self) -> pd.Series[str]: ...
    @property
    def type(self) -> pd.Series[str]: ...
    @property
    def length(self) -> pd.Series[float]: ...
    @property
    def is_valid(self) -> pd.Series[bool]: ...
    @property
    def is_empty(self) -> pd.Series[bool]: ...
    @property
    def is_simple(self) -> pd.Series[bool]: ...
    @property
    def is_ring(self) -> pd.Series[bool]: ...
    @property
    def has_z(self) -> pd.Series[bool]: ...
    @property
    def boundary(self) -> GeoSeries: ...
    @property
    def centroid(self) -> GeoSeries: ...
    def concave_hull(self, ratio: float = 0.0, allow_holes: bool = False) -> GeoSeries: ...
    @property
    def convex_hull(self) -> GeoSeries: ...
    def delaunay_triangles(self, tolerance: float | ArrayLike = 0.0, only_edges: bool | ArrayLike = False) -> GeoSeries: ...
    @property
    def envelope(self) -> GeoSeries: ...
    def minimum_rotated_rectangle(self) -> GeoSeries: ...
    @property
    def exterior(self) -> GeoSeries: ...
    def extract_unique_points(self) -> GeoSeries: ...
    def offset_curve(
        self,
        distance: float | ArrayLike,
        quad_segs: int = 8,
        join_style: Literal["round", "bevel", "mitre"] = "round",
        mitre_limit: float = 5.0,
    ) -> GeoSeries: ...
    @property
    def interiors(self) -> pd.Series[Any]: ...
    def remove_repeated_points(self, tolerance: float = 0.0) -> GeoSeries: ...
    def representative_point(self) -> GeoSeries: ...
    def minimum_bounding_circle(self) -> GeoSeries: ...
    def minimum_bounding_radius(self) -> pd.Series[float]: ...
    def normalize(self) -> GeoSeries: ...
    def make_valid(self) -> GeoSeries: ...
    def reverse(self) -> GeoSeries: ...
    def segmentize(self, max_segment_length: float | ArrayLike) -> GeoSeries: ...
    @property
    def cascaded_union(self) -> BaseGeometry: ...
    @property
    def unary_union(self) -> BaseGeometry: ...
    def contains(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def geom_equals(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def geom_almost_equals(self, other: GeoSeries | BaseGeometry, decimal: int = 6, align: bool = True) -> pd.Series[bool]: ...
    def geom_equals_exact(
        self, other: GeoSeries | BaseGeometry, tolerance: float | ArrayLike, align: bool = True
    ) -> pd.Series[bool]: ...
    def crosses(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def disjoint(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def intersects(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def overlaps(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def touches(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def within(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def covers(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def covered_by(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[bool]: ...
    def distance(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[float]: ...
    def hausdorff_distance(
        self, other: GeoSeries | BaseGeometry, align: bool = True, densify: float | ArrayLike | None = None
    ) -> pd.Series[float]: ...
    def frechet_distance(
        self, other: GeoSeries | BaseGeometry, align: bool = True, densify: float | ArrayLike | None = None
    ) -> pd.Series[float]: ...
    def difference(self, other: GeoSeries | BaseGeometry, align: bool = True) -> GeoSeries: ...
    def symmetric_difference(self, other: GeoSeries | BaseGeometry, align: bool = True) -> GeoSeries: ...
    def union(self, other: GeoSeries | BaseGeometry, align: bool = True) -> GeoSeries: ...
    def intersection(self, other: GeoSeries | BaseGeometry, align: bool = True) -> GeoSeries: ...
    def clip_by_rect(self, xmin: float, ymin: float, xmax: float, ymax: float) -> GeoSeries: ...
    def shortest_line(self, other: GeoSeries | BaseGeometry, align: bool = True) -> GeoSeries: ...
    @property
    def bounds(self) -> pd.DataFrame: ...
    @property
    def total_bounds(self) -> NDArray[np.float_]: ...
    @property
    def sindex(self) -> BaseSpatialIndex: ...
    @property
    def has_sindex(self) -> bool: ...
    def buffer(self, distance: float | ArrayLike, resolution: int = 16, **kwargs) -> GeoSeries: ...
    def simplify(self, tolerance: float | ArrayLike, preserve_topology: bool = True) -> GeoSeries: ...
    def relate(self, other: GeoSeries | BaseGeometry, align: bool = True) -> pd.Series[str]: ...
    def project(self, other: GeoSeries | BaseGeometry, normalized: bool = False, align: bool = True) -> pd.Series[float]: ...
    def interpolate(self, distance: float | ArrayLike, normalized: bool = False) -> GeoSeries: ...
    def affine_transform(self, matrix: Incomplete) -> GeoSeries: ...
    def translate(self, xoff: float = 0.0, yoff: float = 0.0, zoff: float = 0.0) -> GeoSeries: ...
    def rotate(self, angle: float, origin: _Origin = "center", use_radians: bool = False) -> GeoSeries: ...
    def scale(self, xfact: float = 1.0, yfact: float = 1.0, zfact: float = 1.0, origin: _Origin = "center") -> GeoSeries: ...
    def skew(self, xs: float = 0.0, ys: float = 0.0, origin: _Origin = "center", use_radians: bool = False) -> GeoSeries: ...
    @property
    def cx(self) -> _CoordinateIndexer: ...
    def get_coordinates(self, include_z: bool = False, ignore_index: bool = False, index_parts: bool = False) -> pd.DataFrame: ...
    def hilbert_distance(
        self, total_bounds: tuple[float, float, float, float] | Iterable[float] | None = None, level: int = 16
    ) -> pd.Series[int]: ...
    def sample_points(
        self,
        size: int | ArrayLike,
        method: str = "uniform",
        seed: int | ArrayLike | SeedSequence | BitGenerator | RandomGenerator | None = None,  # deprecated alias for rng
        rng: int | ArrayLike | SeedSequence | BitGenerator | RandomGenerator | None = None,
        **kwargs,
    ) -> GeoSeries: ...

class _CoordinateIndexer:
    obj: GeoPandasBase
    def __init__(self, obj: GeoPandasBase) -> None: ...
    def __getitem__(self, key: tuple[int | slice, int | slice]) -> GeoSeries: ...
