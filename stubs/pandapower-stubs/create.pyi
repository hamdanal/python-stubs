from _typeshed import Incomplete
from collections.abc import Mapping, Sequence
from typing import Literal, SupportsFloat as Float, SupportsIndex as Int
from typing_extensions import TypeAlias

import numpy as np
from numpy.typing import NDArray

from pandapower.auxiliary import pandapowerNet

_CostElementType: TypeAlias = Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"]
_SGenGeneratorType: TypeAlias = Literal["current_source", "async", "async_doubly_fed"]

def create_empty_network(
    name: str = "", f_hz: Int | Float = 50.0, sn_mva: Int | Float = 1, add_stdtypes: bool = True
) -> pandapowerNet: ...
def create_bus(
    net: pandapowerNet,
    vn_kv: Int | Float,
    name: str | None = None,
    index: Int | None = None,
    geodata: tuple[Int | Float, Int | Float] | None = None,
    type: Literal["b", "m", "n"] = "b",
    zone: str | None = None,
    in_service: bool = True,
    max_vm_pu: Int | Float = ...,
    min_vm_pu: Int | Float = ...,
    coords: list[tuple[Int | Float, Int | Float]] | None = None,
    **kwargs,
) -> int: ...
def create_buses(
    net: pandapowerNet,
    nr_buses: Int,
    vn_kv: Int | Float,
    index: Int | None = None,
    name: str | None = None,
    type: Literal["b", "m", "n"] = "b",
    geodata: tuple[Int | Float, Int | Float] | list[tuple[Int | Float, Int | Float]] | None = None,
    zone: str | None = None,
    in_service: bool = True,
    max_vm_pu: Int | Float | None = None,
    min_vm_pu: Int | Float | None = None,
    coords: list[list[tuple[Int | Float, Int | Float]]] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_load(
    net: pandapowerNet,
    bus: Int,
    p_mw: Int | Float,
    q_mvar: Int | Float = 0,
    const_z_percent: Int | Float = 0,
    const_i_percent: Int | Float = 0,
    sn_mva: Int | Float = ...,
    name: str | None = None,
    scaling: Int | Float = 1.0,
    index: Int | None = None,
    in_service: bool = True,
    type: Literal["wye", "delta"] = "wye",
    max_p_mw: Int | Float = ...,
    min_p_mw: Int | Float = ...,
    max_q_mvar: Int | Float = ...,
    min_q_mvar: Int | Float = ...,
    controllable: bool = ...,
    **kwargs,
) -> int: ...
def create_loads(
    net: pandapowerNet,
    buses: Sequence[Int],
    p_mw: Int | Float | Sequence[Int | Float],
    q_mvar: Int | Float | Sequence[Int | Float] = 0,
    const_z_percent: Int | Float | Sequence[Int | Float] = 0,
    const_i_percent: Int | Float | Sequence[Int | Float] = 0,
    sn_mva: Int | Float | Sequence[Int | Float] = ...,
    name: Sequence[str] | None = None,
    scaling: Int | Float | Sequence[Int | Float] = 1.0,
    index: Sequence[Int] | None = None,
    in_service: bool | Sequence[bool] = True,
    type: Literal["wye", "delta"] | Sequence[Literal["wye", "delta"]] | None = None,
    max_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    min_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    max_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    min_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    controllable: bool | Sequence[bool] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_asymmetric_load(
    net: pandapowerNet,
    bus: Int,
    p_a_mw: Int | Float = 0,
    p_b_mw: Int | Float = 0,
    p_c_mw: Int | Float = 0,
    q_a_mvar: Int | Float = 0,
    q_b_mvar: Int | Float = 0,
    q_c_mvar: Int | Float = 0,
    sn_mva: Int | Float = ...,
    name: str | None = None,
    scaling: Int | Float = 1.0,
    index: Int | None = None,
    in_service: bool = True,
    type: Literal["wye", "delta"] = "wye",
    **kwargs,
) -> int: ...
def create_load_from_cosphi(
    net: pandapowerNet,
    bus: Int,
    sn_mva: Int | Float,
    cos_phi: Int | Float,
    mode: Literal["underexcited", "overexcited"],
    **kwargs,
) -> int: ...
def create_sgen(
    net: pandapowerNet,
    bus: Int,
    p_mw: Int | Float,
    q_mvar: Int | Float = 0,
    sn_mva: Int | Float = ...,
    name: str | None = None,
    index: Int | None = None,
    scaling: Int | Float = 1,
    type: Literal["wye", "delta", "motor"] = "wye",
    in_service: bool = True,
    max_p_mw: Int | Float = ...,
    min_p_mw: Int | Float = ...,
    max_q_mvar: Int | Float = ...,
    min_q_mvar: Int | Float = ...,
    controllable: bool = ...,
    k: Int | Float = ...,
    rx: Int | Float | None = None,
    current_source: bool = True,
    generator_type: _SGenGeneratorType | None = None,
    max_ik_ka: Int | Float = ...,
    kappa: Int | Float = ...,
    lrc_pu: Int | Float = ...,
    **kwargs,
) -> int: ...
def create_sgens(
    net: pandapowerNet,
    buses: Sequence[Int],
    p_mw: Int | Float | Sequence[Int | Float],
    q_mvar: Int | Float | Sequence[Int | Float] = 0,
    sn_mva: Int | Float | Sequence[Int | Float] = ...,
    name: Sequence[str] | None = None,
    index: Sequence[Int] | None = None,
    scaling: Int | Float | Sequence[Int | Float] = 1.0,
    type: Literal["wye", "delta", "motor"] | Sequence[Literal["wye", "delta", "motor"]] | None = None,
    in_service: bool | Sequence[bool] = True,
    max_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    min_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    max_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    min_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    controllable: bool | Sequence[bool] | None = None,
    k: Int | Float | Sequence[Int | Float] | None = None,
    rx: Int | Float | Sequence[Int | Float] | None = None,
    current_source: bool | Sequence[bool] = True,
    generator_type: _SGenGeneratorType | Sequence[_SGenGeneratorType] = "current_source",
    max_ik_ka: Int | Float = ...,
    kappa: Int | Float = ...,
    lrc_pu: Int | Float = ...,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_asymmetric_sgen(
    net: pandapowerNet,
    bus: Int,
    p_a_mw: Int | Float = 0,
    p_b_mw: Int | Float = 0,
    p_c_mw: Int | Float = 0,
    q_a_mvar: Int | Float = 0,
    q_b_mvar: Int | Float = 0,
    q_c_mvar: Int | Float = 0,
    sn_mva: Int | Float = ...,
    name: str | None = None,
    index: Int | None = None,
    scaling: Int | Float = 1,
    type: Literal["wye", "delta"] = "wye",
    in_service: bool = True,
    **kwargs,
) -> int: ...
def create_sgen_from_cosphi(
    net: pandapowerNet,
    bus: Int,
    sn_mva: Int | Float,
    cos_phi: Int | Float,
    mode: Literal["underexcited", "overexcited"],
    **kwargs,
) -> int: ...
def create_storage(
    net: pandapowerNet,
    bus: Int,
    p_mw: Int | Float,
    max_e_mwh: Int | Float,
    q_mvar: Int | Float = 0,
    sn_mva: Int | Float = ...,
    soc_percent: Int | Float = ...,
    min_e_mwh: Int | Float = 0.0,
    name: str | None = None,
    index: Int | None = None,
    scaling: Int | Float = 1.0,
    type: str | None = None,
    in_service: bool = True,
    max_p_mw: Int | Float = ...,
    min_p_mw: Int | Float = ...,
    max_q_mvar: Int | Float = ...,
    min_q_mvar: Int | Float = ...,
    controllable: bool = ...,
    **kwargs,
) -> int: ...
def create_gen(
    net: pandapowerNet,
    bus: Int,
    p_mw: Int | Float,
    vm_pu: Int | Float = 1.0,
    sn_mva: Int | Float = ...,
    name: str | None = None,
    index: Int | None = None,
    max_q_mvar: Int | Float = ...,
    min_q_mvar: Int | Float = ...,
    min_p_mw: Int | Float = ...,
    max_p_mw: Int | Float = ...,
    min_vm_pu: Int | Float = ...,
    max_vm_pu: Int | Float = ...,
    scaling: Int | Float = 1.0,
    type: str | None = None,
    slack: bool = False,
    controllable: bool = ...,
    vn_kv: Int | Float = ...,
    xdss_pu: Int | Float = ...,
    rdss_ohm: Int | Float = ...,
    cos_phi: Int | Float = ...,
    pg_percent: Int | Float = ...,
    power_station_trafo: Int | None = None,
    in_service: bool = True,
    slack_weight: Int | Float = 0.0,
    **kwargs,
) -> int: ...
def create_gens(
    net: pandapowerNet,
    buses: Sequence[Int],
    p_mw: Int | Float | Sequence[Int | Float],
    vm_pu: Int | Float | Sequence[Int | Float] = 1.0,
    sn_mva: Int | Float | Sequence[Int | Float] = ...,
    name: Sequence[str] | None = None,
    index: Sequence[Int] | None = None,
    max_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    min_q_mvar: Int | Float | Sequence[Int | Float] | None = None,
    min_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    max_p_mw: Int | Float | Sequence[Int | Float] | None = None,
    min_vm_pu: Int | Float | Sequence[Int | Float] | None = None,
    max_vm_pu: Int | Float | Sequence[Int | Float] | None = None,
    scaling: Int | Float | Sequence[Int | Float] = 1,
    type: str | Sequence[str] | None = None,
    slack: bool | Sequence[bool] = False,
    controllable: bool | Sequence[bool] | None = None,
    vn_kv: Int | Float | Sequence[Int | Float] | None = None,
    xdss_pu: Int | Float | Sequence[Int | Float] | None = None,
    rdss_ohm: Int | Float | Sequence[Int | Float] | None = None,
    cos_phi: Int | Float | Sequence[Int | Float] | None = None,
    pg_percent: Int | Float | None = None,
    power_station_trafo: Int | None = None,
    in_service: bool | Sequence[bool] = True,
    slack_weight: Int | Float = 0.0,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_motor(
    net: pandapowerNet,
    bus: Int,
    pn_mech_mw: Int | Float,
    cos_phi: Int | Float,
    efficiency_percent: Int | Float = 100.0,
    loading_percent: Int | Float = 100.0,
    name: str | None = None,
    lrc_pu: Int | Float = ...,
    scaling: Int | Float = 1.0,
    vn_kv: Int | Float = ...,
    rx: Int | Float = ...,
    index: Int | None = None,
    in_service: bool = True,
    cos_phi_n: Int | Float = ...,
    efficiency_n_percent: Int | Float = ...,
    **kwargs,
) -> int: ...
def create_ext_grid(
    net: pandapowerNet,
    bus: Int,
    vm_pu: Int | Float = 1.0,
    va_degree: Int | Float = 0.0,
    name: str | None = None,
    in_service: bool = True,
    s_sc_max_mva: Int | Float = ...,
    s_sc_min_mva: Int | Float = ...,
    rx_max: Int | Float = ...,
    rx_min: Int | Float = ...,
    max_p_mw: Int | Float = ...,
    min_p_mw: Int | Float = ...,
    max_q_mvar: Int | Float = ...,
    min_q_mvar: Int | Float = ...,
    index: Int | None = None,
    r0x0_max: Int | Float = ...,
    x0x_max: Int | Float = ...,
    controllable: bool = ...,
    slack_weight: Int | Float = 1.0,
    **kwargs,
) -> int: ...
def create_line(
    net: pandapowerNet,
    from_bus: Int,
    to_bus: Int,
    length_km: Int | Float,
    std_type: str,
    name: str | None = None,
    index: Int | None = None,
    geodata: Sequence[tuple[Int | Float, Int | Float]] | None = None,
    df: Int | Float = 1.0,
    parallel: Int = 1,
    in_service: bool = True,
    max_loading_percent: Int | Float = ...,
    alpha: Int | Float = ...,
    temperature_degree_celsius: Int | Float = ...,
    **kwargs,
) -> int: ...
def create_lines(
    net: pandapowerNet,
    from_buses: Sequence[Int],
    to_buses: Sequence[Int],
    length_km: Sequence[Int | Float],
    std_type: str | Sequence[str],
    name: str | Sequence[str] | None = None,
    index: Int | None = None,
    geodata: Sequence[Sequence[tuple[Int | Float, Int | Float]]] | None = None,
    df: Int | Float | Sequence[Int | Float] = 1.0,
    parallel: Int | Sequence[Int] = 1,
    in_service: bool | Sequence[bool] = True,
    max_loading_percent: Int | Float | Sequence[Int | Float] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_line_from_parameters(
    net: pandapowerNet,
    from_bus: Int,
    to_bus: Int,
    length_km: Int | Float,
    r_ohm_per_km: Int | Float,
    x_ohm_per_km: Int | Float,
    c_nf_per_km: Int | Float,
    max_i_ka: Int | Float,
    name: str | None = None,
    index: Int | None = None,
    type: Literal["ol", "cs"] | None = None,
    geodata: Sequence[tuple[Int | Float, Int | Float]] | None = None,
    in_service: bool = True,
    df: Int | Float = 1.0,
    parallel: Int = 1,
    g_us_per_km: Int | Float = 0.0,
    max_loading_percent: Int | Float = ...,
    alpha: Int | Float = ...,
    temperature_degree_celsius: Int | Float = ...,
    r0_ohm_per_km: Int | Float = ...,
    x0_ohm_per_km: Int | Float = ...,
    c0_nf_per_km: Int | Float = ...,
    g0_us_per_km: Int | Float = 0.0,
    endtemp_degree: Int | Float = ...,
    **kwargs,
) -> int: ...
def create_lines_from_parameters(
    net: pandapowerNet,
    from_buses: Sequence[Int],
    to_buses: Sequence[Int],
    length_km: Int | Float | Sequence[Int | Float],
    r_ohm_per_km: Int | Float | Sequence[Int | Float],
    x_ohm_per_km: Int | Float | Sequence[Int | Float],
    c_nf_per_km: Int | Float | Sequence[Int | Float],
    max_i_ka: Int | Float | Sequence[Int | Float],
    name: Sequence[str] | None = None,
    index: Sequence[Int] | None = None,
    type: Literal["ol", "cs"] | Sequence[Literal["ol", "cs"]] | None = None,
    geodata: Sequence[Sequence[tuple[Int | Float, Int | Float]]] | None = None,
    in_service: bool | Sequence[bool] = True,
    df: Int | Float | Sequence[Int | Float] = 1.0,
    parallel: Int | Sequence[Int] = 1,
    g_us_per_km: Int | Float | Sequence[Int | Float] = 0.0,
    max_loading_percent: Int | Float | Sequence[Int | Float] | None = None,
    alpha: Int | Float | Sequence[Int | Float] | None = None,
    temperature_degree_celsius: Int | Float | Sequence[Int | Float] | None = None,
    r0_ohm_per_km: Int | Float | Sequence[Int | Float] | None = None,
    x0_ohm_per_km: Int | Float | Sequence[Int | Float] | None = None,
    c0_nf_per_km: Int | Float | Sequence[Int | Float] | None = None,
    g0_us_per_km: Int | Float | Sequence[Int | Float] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_transformer(
    net: pandapowerNet,
    hv_bus: Int,
    lv_bus: Int,
    std_type: str,
    name: str | None = None,
    tap_pos: Int = ...,
    in_service: bool = True,
    index: Int | None = None,
    max_loading_percent: Int | Float = ...,
    parallel: Int = 1,
    df: Int | Float = 1.0,
    tap_dependent_impedance: bool | None = None,
    vk_percent_characteristic: Int | None = None,
    vkr_percent_characteristic: Int | None = None,
    pt_percent: Int | Float | None = None,
    oltc: bool | None = None,
    xn_ohm: Int | Float | None = None,
    **kwargs,
) -> int: ...
def create_transformer_from_parameters(
    net: pandapowerNet,
    hv_bus: Int,
    lv_bus: Int,
    sn_mva: Int | Float,
    vn_hv_kv: Int | Float,
    vn_lv_kv: Int | Float,
    vkr_percent: Int | Float,
    vk_percent: Int | Float,
    pfe_kw: Int | Float,
    i0_percent: Int | Float,
    shift_degree: Int | Float = 0.0,
    tap_side: Literal["hv", "lv"] | None = None,
    tap_neutral: Int = ...,
    tap_max: Int = ...,
    tap_min: Int = ...,
    tap_step_percent: Int = ...,
    tap_step_degree: Int = ...,
    tap_pos: Int = ...,
    tap_phase_shifter: bool = False,
    in_service: bool = True,
    name: str | None = None,
    vector_group: str | None = None,
    index: Int | None = None,
    max_loading_percent: Int | Float = ...,
    parallel: Int = 1,
    df: Int | Float = 1.0,
    vk0_percent: Int | Float = ...,
    vkr0_percent: Int | Float = ...,
    mag0_percent: Int | Float = ...,
    mag0_rx: Int | Float = ...,
    si0_hv_partial: Int | Float = ...,
    pt_percent: Int | Float | None = None,
    oltc: bool | None = None,
    tap_dependent_impedance: bool | None = None,
    vk_percent_characteristic: Int | None = None,
    vkr_percent_characteristic: Int | None = None,
    xn_ohm: Int | Float | None = None,
    **kwargs,
) -> int: ...
def create_transformers_from_parameters(
    net: pandapowerNet,
    hv_buses: Sequence[Int],
    lv_buses: Sequence[Int],
    sn_mva,
    vn_hv_kv,
    vn_lv_kv,
    vkr_percent,
    vk_percent,
    pfe_kw,
    i0_percent,
    shift_degree: Int | Float = 0.0,
    tap_side: Literal["hv", "lv"] | None = None,
    tap_neutral: Incomplete = ...,
    tap_max: Incomplete = ...,
    tap_min: Incomplete = ...,
    tap_step_percent: Incomplete = ...,
    tap_step_degree: Incomplete = ...,
    tap_pos: Incomplete = ...,
    tap_phase_shifter: bool = False,
    in_service: bool = True,
    name: Sequence[str] | None = None,
    vector_group: Incomplete | None = None,
    index: Sequence[Int] | None = None,
    max_loading_percent: Incomplete | None = None,
    parallel: Int = 1,
    df: Int | Float = 1.0,
    vk0_percent: Incomplete | None = None,
    vkr0_percent: Incomplete | None = None,
    mag0_percent: Incomplete | None = None,
    mag0_rx: Incomplete | None = None,
    si0_hv_partial: Incomplete | None = None,
    pt_percent: Incomplete | None = None,
    oltc: Incomplete | None = None,
    tap_dependent_impedance: Incomplete | None = None,
    vk_percent_characteristic: Incomplete | None = None,
    vkr_percent_characteristic: Incomplete | None = None,
    xn_ohm: Incomplete | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_transformer3w(
    net: pandapowerNet,
    hv_bus: Int,
    mv_bus: Int,
    lv_bus: Int,
    std_type: str,
    name: str | None = None,
    tap_pos: Int = ...,
    in_service: bool = True,
    index: Int | None = None,
    max_loading_percent: Int | Float = ...,
    tap_at_star_point: bool = False,
    tap_dependent_impedance: bool | None = None,
    vk_hv_percent_characteristic: Int | None = None,
    vkr_hv_percent_characteristic: Int | None = None,
    vk_mv_percent_characteristic: Int | None = None,
    vkr_mv_percent_characteristic: Int | None = None,
    vk_lv_percent_characteristic: Int | None = None,
    vkr_lv_percent_characteristic: Int | None = None,
    **kwargs,
) -> int: ...
def create_transformer3w_from_parameters(
    net: pandapowerNet,
    hv_bus: Int,
    mv_bus: Int,
    lv_bus: Int,
    vn_hv_kv: Int | Float,
    vn_mv_kv: Int | Float,
    vn_lv_kv: Int | Float,
    sn_hv_mva: Int | Float,
    sn_mv_mva: Int | Float,
    sn_lv_mva: Int | Float,
    vk_hv_percent: Int | Float,
    vk_mv_percent: Int | Float,
    vk_lv_percent: Int | Float,
    vkr_hv_percent: Int | Float,
    vkr_mv_percent: Int | Float,
    vkr_lv_percent: Int | Float,
    pfe_kw: Int | Float,
    i0_percent: Int | Float,
    shift_mv_degree: Int | Float = 0.0,
    shift_lv_degree: Int | Float = 0.0,
    tap_side: Literal["hv", "mv", "lv"] | None = None,
    tap_step_percent: Int | Float = ...,
    tap_step_degree: Int | Float = ...,
    tap_pos: Int = ...,
    tap_neutral: Int = ...,
    tap_max: Int = ...,
    tap_min: Int = ...,
    name: str | None = None,
    in_service: bool = True,
    index: Int | None = None,
    max_loading_percent: Int | Float = ...,
    tap_at_star_point: bool = False,
    vk0_hv_percent: Int | Float = ...,
    vk0_mv_percent: Int | Float = ...,
    vk0_lv_percent: Int | Float = ...,
    vkr0_hv_percent: Int | Float = ...,
    vkr0_mv_percent: Int | Float = ...,
    vkr0_lv_percent: Int | Float = ...,
    vector_group: str | None = None,
    tap_dependent_impedance: Int | None = None,
    vk_hv_percent_characteristic: Int | None = None,
    vkr_hv_percent_characteristic: Int | None = None,
    vk_mv_percent_characteristic: Int | None = None,
    vkr_mv_percent_characteristic: Int | None = None,
    vk_lv_percent_characteristic: Int | None = None,
    vkr_lv_percent_characteristic: Int | None = None,
    **kwargs,
) -> int: ...
def create_transformers3w_from_parameters(
    net: pandapowerNet,
    hv_buses: Sequence[Int],
    mv_buses: Sequence[Int],
    lv_buses: Sequence[Int],
    vn_hv_kv: Int | Float | Sequence[Int | Float],
    vn_mv_kv: Int | Float | Sequence[Int | Float],
    vn_lv_kv: Int | Float | Sequence[Int | Float],
    sn_hv_mva: Int | Float | Sequence[Int | Float],
    sn_mv_mva: Int | Float | Sequence[Int | Float],
    sn_lv_mva: Int | Float | Sequence[Int | Float],
    vk_hv_percent: Int | Float | Sequence[Int | Float],
    vk_mv_percent: Int | Float | Sequence[Int | Float],
    vk_lv_percent: Int | Float | Sequence[Int | Float],
    vkr_hv_percent: Int | Float | Sequence[Int | Float],
    vkr_mv_percent: Int | Float | Sequence[Int | Float],
    vkr_lv_percent: Int | Float | Sequence[Int | Float],
    pfe_kw: Int | Float | Sequence[Int | Float],
    i0_percent: Int | Float | Sequence[Int | Float],
    shift_mv_degree: Int | Float | Sequence[Int | Float] = 0.0,
    shift_lv_degree: Int | Float | Sequence[Int | Float] = 0.0,
    tap_side: Literal["hv", "mv", "lv"] | Sequence[Literal["hv", "mv", "lv"]] | None = None,
    tap_step_percent: Int | Float | Sequence[Int | Float] = ...,
    tap_step_degree: Int | Float | Sequence[Int | Float] = ...,
    tap_pos: Int | Sequence[Int] = ...,
    tap_neutral: Int | Sequence[Int] = ...,
    tap_max: Int | Sequence[Int] = ...,
    tap_min: Int | Sequence[Int] = ...,
    name: Sequence[str] | None = None,
    in_service: bool | Sequence[bool] = True,
    index: Sequence[Int] | None = None,
    max_loading_percent: Incomplete | None = None,
    tap_at_star_point: bool = False,
    vk0_hv_percent: Incomplete = ...,
    vk0_mv_percent: Incomplete = ...,
    vk0_lv_percent: Incomplete = ...,
    vkr0_hv_percent: Incomplete = ...,
    vkr0_mv_percent: Incomplete = ...,
    vkr0_lv_percent: Incomplete = ...,
    vector_group: Incomplete | None = None,
    tap_dependent_impedance: Incomplete | None = None,
    vk_hv_percent_characteristic: Incomplete | None = None,
    vkr_hv_percent_characteristic: Incomplete | None = None,
    vk_mv_percent_characteristic: Incomplete | None = None,
    vkr_mv_percent_characteristic: Incomplete | None = None,
    vk_lv_percent_characteristic: Incomplete | None = None,
    vkr_lv_percent_characteristic: Incomplete | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_switch(
    net: pandapowerNet,
    bus: Int,
    element: Int,
    et: Literal["l", "t", "t3", "b"],
    closed: bool = True,
    type: Literal["LS", "CB", "LBS", "DS"] | None = None,
    name: str | None = None,
    index: Int | None = None,
    z_ohm: Int | Float = 0,
    in_ka: Int | Float | None = None,
    **kwargs,
) -> int: ...
def create_switches(
    net: pandapowerNet,
    buses: Sequence[Int],
    elements: Sequence[Int],
    et: Literal["l", "t", "t3", "b"] | Sequence[Literal["l", "t", "t3", "b"]],
    closed: bool | Sequence[bool] = True,
    type: Literal["LS", "CB", "LBS", "DS"] | Sequence[Literal["LS", "CB", "LBS", "DS"]] | None = None,
    name: Sequence[str] | None = None,
    index: Sequence[Int] | None = None,
    z_ohm: Int | Float | Sequence[Int | Float] = 0,
    in_ka: Int | Float | Sequence[Int | Float] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_shunt(
    net: pandapowerNet,
    bus: Int,
    q_mvar: Int | Float,
    p_mw: Int | Float = 0.0,
    vn_kv: Int | Float | None = None,
    step: Int = 1,
    max_step: Int = 1,
    name: str | None = None,
    in_service: bool = True,
    index: Int | None = None,
    **kwargs,
) -> int: ...
def create_shunts(
    net: pandapowerNet,
    buses: Sequence[Int],
    q_mvar: Int | Float | Sequence[Int | Float],
    p_mw: Int | Float | Sequence[Int | Float] = 0.0,
    vn_kv: Int | Float | Sequence[Int | Float] | None = None,
    step: Int | Sequence[Int] = 1,
    max_step: Int | Sequence[Int] = 1,
    name: Sequence[str] | None = None,
    in_service: bool | Sequence[bool] = True,
    index: Sequence[Int] | None = None,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_shunt_as_capacitor(
    net: pandapowerNet, bus: Int, q_mvar: Int | Float, loss_factor: Int | Float, **kwargs: Incomplete
) -> int: ...
def create_impedance(
    net: pandapowerNet,
    from_bus: Int,
    to_bus: Int,
    rft_pu: Int | Float,
    xft_pu: Int | Float,
    sn_mva: Int | Float,
    rtf_pu: Int | Float | None = None,
    xtf_pu: Int | Float | None = None,
    name: str | None = None,
    in_service: bool = True,
    index: Int | None = None,
    rft0_pu: Int | Float | None = None,
    xft0_pu: Int | Float | None = None,
    rtf0_pu: Int | Float | None = None,
    xtf0_pu: Int | Float | None = None,
    **kwargs,
) -> int: ...
def create_series_reactor_as_impedance(
    net: pandapowerNet,
    from_bus: Int,
    to_bus: Int,
    r_ohm: Int | Float,
    x_ohm: Int | Float,
    sn_mva: Int | Float,
    name: str | None = None,
    in_service: bool = True,
    index: Int | None = None,
    r0_ohm: Int | Float | None = None,
    x0_ohm: Int | Float | None = None,
    **kwargs,
) -> int: ...
def create_ward(
    net: pandapowerNet,
    bus: Int,
    ps_mw: Int | Float,
    qs_mvar: Int | Float,
    pz_mw: Int | Float,
    qz_mvar: Int | Float,
    name: str | None = None,
    in_service: bool = True,
    index: Int | None = None,
    **kwargs,
) -> int: ...
def create_xward(
    net: pandapowerNet,
    bus: Int,
    ps_mw: Int | Float,
    qs_mvar: Int | Float,
    pz_mw: Int | Float,
    qz_mvar: Int | Float,
    r_ohm: Int | Float,
    x_ohm: Int | Float,
    vm_pu: Int | Float,
    in_service: bool = True,
    name: str | None = None,
    index: Int | None = None,
    slack_weight: Int | Float = 0.0,
    **kwargs,
) -> int: ...
def create_dcline(
    net: pandapowerNet,
    from_bus: Int,
    to_bus: Int,
    p_mw: Int | Float,
    loss_percent: Int | Float,
    loss_mw: Int | Float,
    vm_from_pu: Int | Float,
    vm_to_pu: Int | Float,
    index: Int | None = None,
    name: str | None = None,
    max_p_mw: Int | Float = ...,
    min_q_from_mvar: Int | Float = ...,
    min_q_to_mvar: Int | Float = ...,
    max_q_from_mvar: Int | Float = ...,
    max_q_to_mvar: Int | Float = ...,
    in_service: bool = True,
    **kwargs,
) -> int: ...
def create_measurement(
    net: pandapowerNet,
    meas_type: Literal["v", "p", "q", "i", "va", "ia"],
    element_type: Literal["bus", "line", "trafo", "trafo3w"],
    value: Int | Float,
    std_dev: Int | Float,
    element: Int,
    side: Literal["hv", "mv", "lv"] | Int | None = None,
    check_existing: bool = True,
    index: Int | None = None,
    name: str | None = None,
    **kwargs,
) -> int: ...
def create_pwl_cost(
    net: pandapowerNet,
    element: Int,
    et: _CostElementType,
    points: Sequence[Incomplete],
    power_type: Literal["p", "q"] = "p",
    index: Int | None = None,
    check: bool = True,
    **kwargs,
) -> int: ...
def create_pwl_costs(
    net: pandapowerNet,
    elements: Sequence[Int],
    et: _CostElementType | Sequence[_CostElementType],
    points: Sequence[Sequence[Incomplete]],
    power_type: Literal["p", "q"] | Sequence[Literal["p", "q"]] = "p",
    index: Sequence[Int] | None = None,
    check: bool | Sequence[bool] = True,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_poly_cost(
    net: pandapowerNet,
    element: Int,
    et: _CostElementType,
    cp1_eur_per_mw: Int | Float,
    cp0_eur: Int | Float = 0,
    cq1_eur_per_mvar: Int | Float = 0,
    cq0_eur: Int | Float = 0,
    cp2_eur_per_mw2: Int | Float = 0,
    cq2_eur_per_mvar2: Int | Float = 0,
    index: Int | None = None,
    check: bool = True,
    **kwargs,
) -> int: ...
def create_poly_costs(
    net: pandapowerNet,
    elements: Sequence[Int],
    et: _CostElementType | Sequence[_CostElementType],
    cp1_eur_per_mw: Int | Float | Sequence[Int | Float],
    cp0_eur: Int | Float | Sequence[Int | Float] = 0,
    cq1_eur_per_mvar: Int | Float | Sequence[Int | Float] = 0,
    cq0_eur: Int | Float | Sequence[Int | Float] = 0,
    cp2_eur_per_mw2: Int | Float | Sequence[Int | Float] = 0,
    cq2_eur_per_mvar2: Int | Float | Sequence[Int | Float] = 0,
    index: Sequence[Int] | None = None,
    check: bool | Sequence[bool] = True,
    **kwargs,
) -> NDArray[np.int_]: ...
def create_group(
    net: pandapowerNet,
    element_types: str | Sequence[str],
    elements: Sequence[Sequence[Incomplete]],
    name: str = "",
    reference_columns: str | Sequence[str] | None = None,
    index: Int | None = None,
    **kwargs,
) -> int: ...
def create_group_from_dict(
    net: pandapowerNet,
    elements_dict: Mapping[str, Sequence[Incomplete]],
    name: str = "",
    reference_column: Incomplete | None = None,
    index: Int | None = None,
    **kwargs,
) -> int: ...
