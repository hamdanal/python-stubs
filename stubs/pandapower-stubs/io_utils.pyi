import json
import numbers
from _typeshed import Incomplete, ReadableBuffer, StrOrBytesPath, SupportsRead
from collections.abc import Callable, Container, Mapping
from functools import singledispatch
from typing import Any, SupportsIndex as Int, TypeVar, overload
from typing_extensions import Self

import geopandas as gpd
import networkx as nx
import numpy as np
import pandas as pd
import shapely
from shapely.geometry.base import BaseGeometry

from pandapower._typing import SupportsGeoInterface
from pandapower.auxiliary import pandapowerNet

_T = TypeVar("_T")
_D = TypeVar("_D", bound=dict[str, Any])

PSYCOPG2_INSTALLED: bool
cryptography_INSTALLED: bool
hashlib_INSTALLED: bool
base64_INSTALLED: bool
zlib_INSTALLED: bool
GEOPANDAS_INSTALLED: bool
SHAPELY_INSTALLED: bool

def coords_to_df(value: pd.DataFrame, geotype: str = "line") -> pd.DataFrame: ...
def to_dict_of_dfs(
    net: pandapowerNet,
    include_results: bool = False,
    include_std_types: bool = True,
    include_parameters: bool = True,
    include_empty_tables: bool = True,
) -> dict[str, pd.DataFrame]: ...
def dicts_to_pandas(json_dict: Mapping[str, dict[object, object]]) -> dict[str, pd.DataFrame]: ...
def df_to_coords(net: pandapowerNet, item: str, table: pd.DataFrame) -> None: ...
def from_dict_of_dfs(dodfs: Mapping[str, pd.DataFrame], net: pandapowerNet | None = None) -> pandapowerNet: ...
def restore_all_dtypes(net: pandapowerNet, dtypes: pd.DataFrame) -> None: ...
def to_dict_with_coord_transform(
    net: pandapowerNet, point_geo_columns: Container[str], line_geo_columns: Container[str]
) -> dict[str, dict[str, dict[Incomplete, Incomplete]]]: ...
def get_raw_data_from_pickle(filename: SupportsRead[bytes] | StrOrBytesPath) -> Incomplete: ...  # -> pandapowerNet?
def transform_net_with_df_and_geo(
    net: pandapowerNet, point_geo_columns: Container[str], line_geo_columns: Container[str]
) -> None: ...
def isinstance_partial(obj: object, cls: type[object]) -> bool: ...
def check_net_version(net: pandapowerNet) -> None: ...

class PPJSONEncoder(json.JSONEncoder):
    isinstance_func: Callable[[object, type[object]], bool]
    def __init__(
        self,
        isinstance_func: Callable[[object, type[object]], bool] = ...,
        # json.JSONEncoder.__init__ kwargs
        *,
        skipkeys: bool = False,
        ensure_ascii: bool = True,
        check_circular: bool = True,
        allow_nan: bool = True,
        sort_keys: bool = False,
        indent: int | str | None = None,
        separators: tuple[str, str] | None = None,
        default: Callable[..., Any] | None = None,
    ) -> None: ...
    def iterencode(self, o: object, _one_shot: bool = False) -> Any: ...
    def default(self, o: object) -> Any: ...

class FromSerializable:
    class_name: str
    module_name: str
    registry: dict[tuple[str, str], Incomplete]
    def __init__(self) -> None: ...
    @overload
    def __get__(self, instance: None, owner: type[object]) -> Self: ...
    @overload
    def __get__(self, instance: _T, owner: type[_T]) -> Incomplete: ...
    def register(self, class_name: str = "", module_name: str = "") -> Callable[[_T], _T]: ...

class FromSerializableRegistry:
    from_serializable: FromSerializable
    class_name: str
    module_name: str
    obj: Any
    d: dict[str, Any]
    pp_hook: Callable[..., Incomplete]
    def __init__(
        self, obj: Any, d: dict[str, Any], pp_hook_funct: Callable[..., Incomplete], ignore_unknown_objects: bool = False
    ) -> None: ...
    def Series(self) -> pd.Series[Any]: ...
    def DataFrame(self) -> pd.DataFrame: ...
    def pandapowerNet(self) -> pandapowerNet: ...
    def networkx(self) -> Incomplete: ...
    def method(self) -> Incomplete: ...
    def function(self) -> Incomplete: ...
    def rest(self) -> Incomplete: ...
    def GeoDataFrame(self) -> gpd.GeoDataFrame: ...
    def shapely(self) -> BaseGeometry: ...

class PPJSONDecoder(json.JSONDecoder):
    def __init__(self, **kwargs: Incomplete) -> None: ...

def pp_hook(
    d: _D,
    deserialize_pandas: bool = True,
    empty_dict_like_object: Incomplete | None = None,
    registry_class: type[FromSerializableRegistry] = ...,
    ignore_unknown_objects: bool = False,
) -> _D: ...
def encrypt_string(s: str, key: str, compress: bool = True) -> str: ...
def decrypt_string(s: str, key: str) -> str: ...

class JSONSerializableClass:
    json_excludes: list[str]
    def __init__(self, **kwargs: object) -> None: ...
    def to_json(self) -> str: ...
    def to_dict(self) -> dict[str, Incomplete]: ...
    def add_to_net(
        self,
        net: pandapowerNet,
        element: str,
        index: Int | None = None,
        column: str = "object",
        overwrite: bool = False,
        preserve_dtypes: bool = False,
        fill_dict: dict[str, Any] | None = None,
    ) -> np.int64: ...
    def equals(self, other: object) -> bool: ...
    @classmethod
    def from_dict(cls, d: dict[str, object]) -> Self: ...
    @classmethod
    def from_json(cls, json_string: str | ReadableBuffer) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

def with_signature(obj: object, val: object, obj_module: str | None = None, obj_class: str | None = None) -> dict[str, Any]: ...
@singledispatch
def to_serializable(obj: object) -> Incomplete: ...
@to_serializable.register(pandapowerNet)
def json_pandapowernet(obj: pandapowerNet) -> dict[str, Any]: ...
@to_serializable.register(pd.DataFrame)
def json_dataframe(obj: pd.DataFrame) -> dict[str, Any]: ...
@to_serializable.register(gpd.GeoDataFrame)
def json_geodataframe(obj: gpd.GeoDataFrame) -> dict[str, Any]: ...
@to_serializable.register(pd.Series)
def json_series(obj: pd.Series[Any]) -> dict[str, Any]: ...
@to_serializable.register(np.ndarray)
def json_array(obj: np.ndarray[Any, Any]) -> dict[str, Any]: ...
@to_serializable.register(np.integer)
def json_npint(obj: np.integer[Any]) -> dict[str, Any]: ...
@to_serializable.register(np.floating)
def json_npfloat(obj: np.floating[Any]) -> dict[str, Any]: ...
@to_serializable.register(np.bool)
def json_npbool(obj: np.bool) -> dict[str, Any]: ...
@to_serializable.register(numbers.Number)
def json_num(obj: numbers.Number) -> str: ...
@to_serializable.register(complex)
def json_complex(obj: complex) -> dict[str, Any]: ...
@to_serializable.register(pd.Index)
def json_pdindex(obj: pd.Index[Any]) -> dict[str, Any]: ...
@to_serializable.register(bool)
def json_bool(obj: bool) -> str: ...
@to_serializable.register(tuple)
def json_tuple(obj: tuple[Any, ...]) -> dict[str, Any]: ...
@to_serializable.register(set)
def json_set(obj: set[Any]) -> dict[str, Any]: ...
@to_serializable.register(frozenset)
def json_frozenset(obj: frozenset[Any]) -> dict[str, Any]: ...
@to_serializable.register(nx.Graph)
def json_networkx(obj: nx.Graph[Any]) -> dict[str, Any]: ...
@to_serializable.register(JSONSerializableClass)
def controller_to_serializable(obj: JSONSerializableClass) -> dict[str, Any]: ...
@to_serializable.register(shapely.LineString)
def json_linestring(obj: SupportsGeoInterface) -> dict[str, Any]: ...
@to_serializable.register(shapely.Point)
def json_point(obj: SupportsGeoInterface) -> dict[str, Any]: ...
@to_serializable.register(shapely.Polygon)
def json_polygon(obj: SupportsGeoInterface) -> dict[str, Any]: ...
def mkdirs_if_not_existent(dir_to_create: StrOrBytesPath) -> bool: ...
