from typing import Any, Literal, SupportsIndex, TypeVar, overload as typing_overload

import pandas as pd

from pandapower.auxiliary import pandapowerNet

_IntT = TypeVar("_IntT", bound=SupportsIndex)

log_message_sep: str

@typing_overload
def diagnostic(
    net: pandapowerNet,
    report_style: Literal["detailed", "compact", "None"] = "detailed",
    warnings_only: bool = False,
    return_result_dict: Literal[True] = True,
    overload_scaling_factor: float = 0.001,
    min_r_ohm: float = 0.001,
    min_x_ohm: float = 0.001,
    max_r_ohm: float = 100,
    max_x_ohm: float = 100,
    nom_voltage_tolerance: float = 0.3,
    numba_tolerance: float = 1e-05,
    **kwargs,
) -> dict[str, Any]: ...
@typing_overload
def diagnostic(
    net: pandapowerNet,
    *,
    report_style: Literal["detailed", "compact", "None"] = "detailed",
    warnings_only: bool = False,
    return_result_dict: Literal[False],
    overload_scaling_factor: float = 0.001,
    min_r_ohm: float = 0.001,
    min_x_ohm: float = 0.001,
    max_r_ohm: float = 100,
    max_x_ohm: float = 100,
    nom_voltage_tolerance: float = 0.3,
    numba_tolerance: float = 1e-05,
    **kwargs,
) -> None: ...
def check_greater_zero(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_greater_equal_zero(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_less_zero(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_less_15(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_less_equal_zero(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_boolean(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_pos_int(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_number(element: pd.Series[Any], element_index: _IntT, column: str) -> _IntT | None: ...
def check_greater_zero_less_equal_one(element: pd.Series[Any], element_index: int, column: str) -> int | None: ...
def check_switch_type(element: pd.Series[Any], element_index: int, column: str) -> int | None: ...
def invalid_values(net: pandapowerNet) -> dict[str, list[tuple[int, str, str, Any]]] | None: ...
def no_ext_grid(net: pandapowerNet) -> bool | None: ...
def multiple_voltage_controlling_elements_per_bus(net: pandapowerNet) -> dict[str, list[int]] | None: ...
def overload(net: pandapowerNet, overload_scaling_factor: float) -> dict[str, bool] | None: ...
def wrong_switch_configuration(net: pandapowerNet, **kwargs) -> bool | None: ...
def missing_bus_indices(net: pandapowerNet) -> dict[str, list[tuple[int, str, int]]] | None: ...
def different_voltage_levels_connected(net: pandapowerNet) -> dict[str, list[int]] | None: ...
def implausible_impedance_values(
    net: pandapowerNet, min_r_ohm: float, min_x_ohm: float, max_r_ohm: float, max_x_ohm: float
) -> list[dict[str, Any]] | None: ...
def nominal_voltages_dont_match(net: pandapowerNet, nom_voltage_tolerance: float) -> dict[str, dict[str, list[int]]] | None: ...
def disconnected_elements(net: pandapowerNet) -> list[dict[str, list[int]]] | None: ...
def wrong_reference_system(net: pandapowerNet) -> dict[str, list[int]] | None: ...
def numba_comparison(net: pandapowerNet, numba_tolerance: float, **kwargs) -> dict[str, dict[str, float]] | None: ...
def deviation_from_std_type(net: pandapowerNet) -> dict[str, dict[int, dict[str, Any]]] | None: ...
def parallel_switches(net: pandapowerNet) -> list[list[int]] | None: ...
