import json
from _typeshed import Incomplete, ReadableBuffer, StrOrBytesPath, SupportsRead
from collections.abc import Callable, Container, Mapping
from functools import singledispatch
from typing import Any, TypeVar
from typing_extensions import Self

import pandas as pd
from pandapower.auxiliary import pandapowerNet

_T = TypeVar("_T")

PSYCOPG2_INSTALLED: bool
cryptography_INSTALLED: bool
hashlib_INSTALLED: bool
base64_INSTALLED: bool
zlib_INSTALLED: bool
GEOPANDAS_INSTALLED: bool
SHAPELY_INSTALLED: bool

def coords_to_df(value: pd.DataFrame, geotype: str = "line") -> pd.DataFrame: ...
def to_dict_of_dfs(
    net: pandapowerNet,
    include_results: bool = False,
    include_std_types: bool = True,
    include_parameters: bool = True,
    include_empty_tables: bool = True,
) -> dict[str, pd.DataFrame]: ...
def dicts_to_pandas(json_dict: Mapping[str, dict[object, object]]) -> dict[str, pd.DataFrame]: ...
def df_to_coords(net: pandapowerNet, item: str, table: pd.DataFrame) -> None: ...
def from_dict_of_dfs(dodfs: Mapping[str, pd.DataFrame], net: pandapowerNet | None = None) -> pandapowerNet: ...
def restore_all_dtypes(net: pandapowerNet, dtypes: pd.DataFrame) -> None: ...
def to_dict_with_coord_transform(
    net: pandapowerNet, point_geo_columns: Container[str], line_geo_columns: Container[str]
) -> dict[str, dict[str, dict[Incomplete, Incomplete]]]: ...
def get_raw_data_from_pickle(filename: SupportsRead[bytes] | StrOrBytesPath) -> Incomplete: ...  # -> pandapowerNet?
def transform_net_with_df_and_geo(
    net: pandapowerNet, point_geo_columns: Container[str], line_geo_columns: Container[str]
) -> None: ...
def isinstance_partial(obj: object, cls: type[object]) -> bool: ...

class PPJSONEncoder(json.JSONEncoder):
    isinstance_func: Callable[[object, type[object]], bool]
    def __init__(
        self,
        isinstance_func: Callable[[object, type[object]], bool] = ...,
        # json.JSONEncoder.__init__ kwargs
        *,
        skipkeys: bool = ...,
        ensure_ascii: bool = ...,
        check_circular: bool = ...,
        allow_nan: bool = ...,
        sort_keys: bool = ...,
        indent: int | str | None = ...,
        separators: tuple[str, str] | None = ...,
        default: Callable[..., Any] | None = ...,
    ) -> None: ...
    def iterencode(self, o: object, _one_shot: bool = False) -> Incomplete: ...
    def default(self, o: object) -> Any: ...

class FromSerializable:
    class_name: str
    module_name: str
    registry: dict[tuple[str, str], Incomplete]
    def __init__(self) -> None: ...
    def __get__(self, instance: Incomplete, owner: Incomplete) -> Incomplete: ...
    def register(self, class_name: str = "", module_name: str = "") -> Callable[[_T], _T]: ...

class FromSerializableRegistry:
    from_serializable: FromSerializable
    class_name: str
    module_name: str
    obj: Incomplete
    d: Incomplete
    pp_hook: Incomplete
    def __init__(self, obj: Incomplete, d: Incomplete, pp_hook_funct: Incomplete) -> None: ...
    def Series(self) -> pd.Series[Incomplete]: ...
    def DataFrame(self) -> pd.DataFrame: ...
    def pandapowerNet(self) -> pandapowerNet: ...
    def networkx(self) -> Incomplete: ...
    def method(self) -> Incomplete: ...
    def function(self) -> Incomplete: ...
    def rest(self) -> Incomplete: ...
    def GeoDataFrame(self) -> Incomplete: ...
    def shapely(self) -> Incomplete: ...

class PPJSONDecoder(json.JSONDecoder):
    def __init__(self, **kwargs: Incomplete) -> None: ...

def pp_hook(
    d: dict[str, Incomplete],
    deserialize_pandas: bool = True,
    empty_dict_like_object: Incomplete | None = None,
    registry_class: type[FromSerializableRegistry] = ...,
) -> dict[str, Incomplete]: ...
def encrypt_string(s: str, key: str, compress: bool = True) -> str: ...
def decrypt_string(s: str, key: str) -> str: ...

class JSONSerializableClass:
    json_excludes: list[str]
    def __init__(self, **kwargs: object) -> None: ...
    def to_json(self) -> str: ...
    def to_dict(self) -> dict[str, Incomplete]: ...
    def add_to_net(
        self,
        net: pandapowerNet,
        element: str,
        index: int | None = None,
        column: str = "object",
        overwrite: bool = False,
        preserve_dtypes: bool = False,
        fill_dict: dict[str, Incomplete] | None = None,
    ) -> int: ...
    def equals(self, other: object) -> bool: ...
    @classmethod
    def from_dict(cls, d: dict[str, object]) -> Self: ...
    @classmethod
    def from_json(cls, json_string: str | ReadableBuffer) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

def with_signature(
    obj: Incomplete, val: Incomplete, obj_module: str | None = ..., obj_class: str | None = ...
) -> dict[str, Incomplete]: ...
@singledispatch
def to_serializable(obj: object) -> Incomplete: ...

# @to_serializable.register(pandapowerNet)
# def json_pandapowernet(obj: pandapowerNet) -> dict[str, Incomplete]: ...
# @to_serializable.register(pd.DataFrame)
# def json_dataframe(obj: pd.DataFrame) -> Incomplete: ...
# # @to_serializable.register(geopandas.GeoDataFrame)
# def json_geodataframe(obj: Incomplete) -> Incomplete: ...
# @to_serializable.register(pd.Series)
# def json_series(obj: pd.Series[Any]) -> dict[str, Incomplete]: ...
# @to_serializable.register(np.ndarray)
# def json_array(obj: np.ndarray[Any, Any]) -> dict[str, Incomplete]: ...
# @to_serializable.register(np.integer)
# def json_npint(obj: np.integer[Any]) -> dict[str, Incomplete]: ...
# @to_serializable.register(np.floating)
# def json_npfloat(obj: np.floating[Any]) -> dict[str, Incomplete]: ...
# @to_serializable.register(np.bool_)
# def json_npbool(obj: np.bool_) -> dict[str, Incomplete]: ...
# @to_serializable.register(numbers.Number)
# def json_num(obj: numbers.Number) -> str: ...
# @to_serializable.register(complex)
# def json_complex(obj: complex) -> dict[str, Incomplete]: ...
# @to_serializable.register(pd.Index)
# def json_pdindex(obj: pd.Index) -> dict[str, Incomplete]: ...
# @to_serializable.register(bool)
# def json_bool(obj: bool) -> str: ...
# @to_serializable.register(tuple)
# def json_tuple(obj: tuple[Any, ...]) -> dict[str, Incomplete]: ...
# @to_serializable.register(set)
# def json_set(obj: set[Any]) -> dict[str, Incomplete]: ...
# @to_serializable.register(frozenset)
# def json_frozenset(obj: frozenset[Any]) -> dict[str, Incomplete]: ...
# # @to_serializable.register(networkx.Graph)
# def json_networkx(obj: Incomplete) -> dict[str, Incomplete]: ...
# @to_serializable.register(JSONSerializableClass)
# def controller_to_serializable(obj: JSONSerializableClass) -> dict[str, Incomplete]: ...
# # @to_serializable.register(shapely.geometry.LineString)
# def json_linestring(obj: Incomplete) -> dict[str, Incomplete]: ...
# # @to_serializable.register(shapely.geometry.Point)
# def json_point(obj: Incomplete) -> dict[str, Incomplete]: ...
# # @to_serializable.register(shapely.geometry.Polygon)
# def json_polygon(obj: Incomplete) -> dict[str, Incomplete]: ...
def mkdirs_if_not_existent(dir_to_create: StrOrBytesPath) -> bool: ...
