from _typeshed import Incomplete
from collections.abc import Mapping, Sequence
from typing import Literal

import numpy as np
from numpy.typing import NDArray
from pandapower.auxiliary import pandapowerNet

def create_empty_network(name: str = "", f_hz: float = 50, sn_mva: int = 1, add_stdtypes: bool = True) -> pandapowerNet: ...
def create_bus(
    net: pandapowerNet,
    vn_kv: float,
    name: str | None = None,
    index: int | None = None,
    geodata: tuple[int, int] | None = None,
    type: Literal["b", "m", "n"] = "b",
    zone: str | None = None,
    in_service: bool = True,
    max_vm_pu: float = ...,
    min_vm_pu: float = ...,
    coords: list[tuple[int, int]] | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_buses(
    net: pandapowerNet,
    nr_buses: int,
    vn_kv: float,
    index: int | None = None,
    name: str | None = None,
    type: Literal["b", "m", "n"] = "b",
    geodata: tuple[int, int] | list[tuple[int, int]] | None = None,
    zone: str | None = None,
    in_service: bool = True,
    max_vm_pu: float | None = None,
    min_vm_pu: float | None = None,
    coords: list[list[tuple[int, int]]] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_load(
    net: pandapowerNet,
    bus: int,
    p_mw: float,
    q_mvar: float = 0,
    const_z_percent: float = 0,
    const_i_percent: float = 0,
    sn_mva: float = ...,
    name: str | None = None,
    scaling: float = 1,
    index: int | None = None,
    in_service: bool = True,
    type: Literal["wye", "delta"] = "wye",
    max_p_mw: float = ...,
    min_p_mw: float = ...,
    max_q_mvar: float = ...,
    min_q_mvar: float = ...,
    controllable: bool = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_loads(
    net: pandapowerNet,
    buses: Sequence[int],
    p_mw: float | Sequence[float],
    q_mvar: float | Sequence[float] = 0,
    const_z_percent: float | Sequence[float] = 0,
    const_i_percent: float | Sequence[float] = 0,
    sn_mva: float | Sequence[float] = ...,
    name: Sequence[str] | None = None,
    scaling: float | Sequence[float] = 1,
    index: Sequence[int] | None = None,
    in_service: bool | Sequence[bool] = True,
    type: Literal["wye", "delta"] | Sequence[Literal["wye", "delta"]] | None = None,
    max_p_mw: float | Sequence[float] | None = None,
    min_p_mw: float | Sequence[float] | None = None,
    max_q_mvar: float | Sequence[float] | None = None,
    min_q_mvar: float | Sequence[float] | None = None,
    controllable: bool | Sequence[bool] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_asymmetric_load(
    net: pandapowerNet,
    bus: int,
    p_a_mw: float = 0,
    p_b_mw: float = 0,
    p_c_mw: float = 0,
    q_a_mvar: float = 0,
    q_b_mvar: float = 0,
    q_c_mvar: float = 0,
    sn_mva: float = ...,
    name: str | None = None,
    scaling: float = 1,
    index: int | None = None,
    in_service: bool = True,
    type: Literal["wye", "delta"] = "wye",
    **kwargs: Incomplete,
) -> int: ...
def create_load_from_cosphi(
    net: pandapowerNet,
    bus: int,
    sn_mva: float,
    cos_phi: float,
    mode: Literal["underexcited", "overexcited"],
    **kwargs: Incomplete,
) -> int: ...
def create_sgen(
    net: pandapowerNet,
    bus: int,
    p_mw: float,
    q_mvar: float = 0,
    sn_mva: float = ...,
    name: str | None = None,
    index: int | None = None,
    scaling: float = 1,
    type: Literal["wye", "delta"] = "wye",
    in_service: bool = True,
    max_p_mw: float = ...,
    min_p_mw: float = ...,
    max_q_mvar: float = ...,
    min_q_mvar: float = ...,
    controllable: bool = ...,
    k: float = ...,
    rx: float | None = None,
    current_source: bool = True,
    generator_type: Literal["current_source", "async", "async_doubly_fed"] | None = None,
    max_ik_ka: float = ...,
    kappa: float = ...,
    lrc_pu: float = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_sgens(
    net: pandapowerNet,
    buses: Sequence[int],
    p_mw: float | Sequence[float],
    q_mvar: float | Sequence[float] = 0,
    sn_mva: float | Sequence[float] = ...,
    name: Sequence[str] | None = None,
    index: Sequence[int] | None = None,
    scaling: float | Sequence[float] = 1,
    type: Literal["wye", "delta"] | Sequence[Literal["wye", "delta"]] | None = None,
    in_service: bool | Sequence[bool] = True,
    max_p_mw: float | Sequence[float] | None = None,
    min_p_mw: float | Sequence[float] | None = None,
    max_q_mvar: float | Sequence[float] | None = None,
    min_q_mvar: float | Sequence[float] | None = None,
    controllable: bool | Sequence[bool] | None = None,
    k: float | Sequence[float] | None = None,
    rx: float | Sequence[float] | None = None,
    current_source: bool | Sequence[bool] = True,
    generator_type: Literal["current_source", "async", "async_doubly_fed"]
    | Sequence[Literal["current_source", "async", "async_doubly_fed"]] = "current_source",
    max_ik_ka: float = ...,
    kappa: float = ...,
    lrc_pu: float = ...,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_asymmetric_sgen(
    net: pandapowerNet,
    bus: int,
    p_a_mw: float = 0,
    p_b_mw: float = 0,
    p_c_mw: float = 0,
    q_a_mvar: float = 0,
    q_b_mvar: float = 0,
    q_c_mvar: float = 0,
    sn_mva: float = ...,
    name: str | None = None,
    index: int | None = None,
    scaling: float = 1,
    type: Literal["wye", "delta"] = "wye",
    in_service: bool = True,
    **kwargs: Incomplete,
) -> int: ...
def create_sgen_from_cosphi(
    net: pandapowerNet,
    bus: int,
    sn_mva: float,
    cos_phi: float,
    mode: Literal["underexcited", "overexcited"],
    **kwargs: Incomplete,
) -> int: ...
def create_storage(
    net: pandapowerNet,
    bus: int,
    p_mw: float,
    max_e_mwh: float,
    q_mvar: float = 0,
    sn_mva: float = ...,
    soc_percent: float = ...,
    min_e_mwh: float = 0,
    name: str | None = None,
    index: int | None = None,
    scaling: float = 1,
    type: str | None = None,
    in_service: bool = True,
    max_p_mw: float = ...,
    min_p_mw: float = ...,
    max_q_mvar: float = ...,
    min_q_mvar: float = ...,
    controllable: bool = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_gen(
    net: pandapowerNet,
    bus: int,
    p_mw: float,
    vm_pu: float = 1,
    sn_mva: float = ...,
    name: str | None = None,
    index: int | None = None,
    max_q_mvar: float = ...,
    min_q_mvar: float = ...,
    min_p_mw: float = ...,
    max_p_mw: float = ...,
    min_vm_pu: float = ...,
    max_vm_pu: float = ...,
    scaling: float = 1,
    type: str | None = None,
    slack: bool = False,
    controllable: bool = ...,
    vn_kv: float = ...,
    xdss_pu: float = ...,
    rdss_ohm: float = ...,
    cos_phi: float = ...,
    pg_percent: float = ...,
    power_station_trafo: int | None = None,
    in_service: bool = True,
    slack_weight: float = 0,
    **kwargs: Incomplete,
) -> int: ...
def create_gens(
    net: pandapowerNet,
    buses: Sequence[int],
    p_mw: float | Sequence[float],
    vm_pu: float | Sequence[float] = 1,
    sn_mva: float | Sequence[float] = ...,
    name: Sequence[str] | None = None,
    index: Sequence[int] | None = None,
    max_q_mvar: float | Sequence[float] | None = None,
    min_q_mvar: float | Sequence[float] | None = None,
    min_p_mw: float | Sequence[float] | None = None,
    max_p_mw: float | Sequence[float] | None = None,
    min_vm_pu: float | Sequence[float] | None = None,
    max_vm_pu: float | Sequence[float] | None = None,
    scaling: float | Sequence[float] = 1,
    type: str | Sequence[str] | None = None,
    slack: bool | Sequence[bool] = False,
    controllable: bool | Sequence[bool] | None = None,
    vn_kv: float | Sequence[float] | None = None,
    xdss_pu: float | Sequence[float] | None = None,
    rdss_ohm: float | Sequence[float] | None = None,
    cos_phi: float | Sequence[float] | None = None,
    pg_percent: float | None = None,
    power_station_trafo: int | None = None,
    in_service: bool | Sequence[bool] = True,
    slack_weight: float = 0,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_motor(
    net: pandapowerNet,
    bus: int,
    pn_mech_mw: float,
    cos_phi: float,
    efficiency_percent: float = 100,
    loading_percent: float = 100,
    name: str | None = None,
    lrc_pu: float = ...,
    scaling: float = 1,
    vn_kv: float = ...,
    rx: float = ...,
    index: int | None = None,
    in_service: bool = True,
    cos_phi_n: float = ...,
    efficiency_n_percent: float = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_ext_grid(
    net: pandapowerNet,
    bus: int,
    vm_pu: float = 1,
    va_degree: float = 0,
    name: str | None = None,
    in_service: bool = True,
    s_sc_max_mva: float = ...,
    s_sc_min_mva: float = ...,
    rx_max: float = ...,
    rx_min: float = ...,
    max_p_mw: float = ...,
    min_p_mw: float = ...,
    max_q_mvar: float = ...,
    min_q_mvar: float = ...,
    index: int | None = None,
    r0x0_max: float = ...,
    x0x_max: float = ...,
    controllable: bool = ...,
    slack_weight: float = 1,
    **kwargs: Incomplete,
) -> int: ...
def create_line(
    net: pandapowerNet,
    from_bus: int,
    to_bus: int,
    length_km: float,
    std_type: str,
    name: str | None = None,
    index: int | None = None,
    geodata: Sequence[tuple[int, int]] | None = None,
    df: float = 1,
    parallel: int = 1,
    in_service: bool = True,
    max_loading_percent: float = ...,
    alpha: float = ...,
    temperature_degree_celsius: float = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_lines(
    net: pandapowerNet,
    from_buses: Sequence[int],
    to_buses: Sequence[int],
    length_km: Sequence[float],
    std_type: str | Sequence[str],
    name: str | Sequence[str] | None = None,
    index: int | None = None,
    geodata: Sequence[Sequence[tuple[int, int]]] | None = None,
    df: float | Sequence[float] = 1,
    parallel: int | Sequence[int] = 1,
    in_service: bool | Sequence[bool] = True,
    max_loading_percent: float | Sequence[float] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_line_from_parameters(
    net: pandapowerNet,
    from_bus: int,
    to_bus: int,
    length_km: float,
    r_ohm_per_km: float,
    x_ohm_per_km: float,
    c_nf_per_km: float,
    max_i_ka: float,
    name: str | None = None,
    index: int | None = None,
    type: Literal["ol", "cs"] | None = None,
    geodata: Sequence[tuple[int, int]] | None = None,
    in_service: bool = True,
    df: float = 1,
    parallel: int = 1,
    g_us_per_km: float = 0,
    max_loading_percent: float = ...,
    alpha: float = ...,
    temperature_degree_celsius: float = ...,
    r0_ohm_per_km: float = ...,
    x0_ohm_per_km: float = ...,
    c0_nf_per_km: float = ...,
    g0_us_per_km: float = 0,
    endtemp_degree: float = ...,
    **kwargs: Incomplete,
) -> int: ...
def create_lines_from_parameters(
    net: pandapowerNet,
    from_buses: Sequence[int],
    to_buses: Sequence[int],
    length_km: float | Sequence[float],
    r_ohm_per_km: float | Sequence[float],
    x_ohm_per_km: float | Sequence[float],
    c_nf_per_km: float | Sequence[float],
    max_i_ka: float | Sequence[float],
    name: Sequence[str] | None = None,
    index: Sequence[int] | None = None,
    type: Literal["ol", "cs"] | Sequence[Literal["ol", "cs"]] | None = None,
    geodata: Sequence[Sequence[tuple[int, int]]] | None = None,
    in_service: bool | Sequence[bool] = True,
    df: float | Sequence[float] = 1,
    parallel: int | Sequence[int] = 1,
    g_us_per_km: float | Sequence[float] = 0,
    max_loading_percent: float | Sequence[float] | None = None,
    alpha: float | Sequence[float] | None = None,
    temperature_degree_celsius: float | Sequence[float] | None = None,
    r0_ohm_per_km: float | Sequence[float] | None = None,
    x0_ohm_per_km: float | Sequence[float] | None = None,
    c0_nf_per_km: float | Sequence[float] | None = None,
    g0_us_per_km: float | Sequence[float] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_transformer(
    net: pandapowerNet,
    hv_bus: int,
    lv_bus: int,
    std_type: str,
    name: str | None = None,
    tap_pos: int = ...,
    in_service: bool = True,
    index: int | None = None,
    max_loading_percent: float = ...,
    parallel: int = 1,
    df: float = 1,
    tap_dependent_impedance: bool | None = None,
    vk_percent_characteristic: int | None = None,
    vkr_percent_characteristic: int | None = None,
    pt_percent: float | None = None,
    oltc: bool | None = None,
    xn_ohm: float | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_transformer_from_parameters(
    net: pandapowerNet,
    hv_bus: int,
    lv_bus: int,
    sn_mva: float,
    vn_hv_kv: float,
    vn_lv_kv: float,
    vkr_percent: float,
    vk_percent: float,
    pfe_kw: float,
    i0_percent: float,
    shift_degree: float = 0,
    tap_side: Literal["hv", "lv"] | None = None,
    tap_neutral: int = ...,
    tap_max: int = ...,
    tap_min: int = ...,
    tap_step_percent: int = ...,
    tap_step_degree: int = ...,
    tap_pos: int = ...,
    tap_phase_shifter: bool = False,
    in_service: bool = True,
    name: str | None = None,
    vector_group: str | None = None,
    index: int | None = None,
    max_loading_percent: float = ...,
    parallel: int = 1,
    df: float = 1,
    vk0_percent: float = ...,
    vkr0_percent: float = ...,
    mag0_percent: float = ...,
    mag0_rx: float = ...,
    si0_hv_partial: float = ...,
    pt_percent: float | None = None,
    oltc: bool | None = None,
    tap_dependent_impedance: bool | None = None,
    vk_percent_characteristic: int | None = None,
    vkr_percent_characteristic: int | None = None,
    xn_ohm: float | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_transformers_from_parameters(
    net: pandapowerNet,
    hv_buses: Sequence[int],
    lv_buses: Sequence[int],
    sn_mva,
    vn_hv_kv,
    vn_lv_kv,
    vkr_percent,
    vk_percent,
    pfe_kw,
    i0_percent,
    shift_degree=0,
    tap_side: Incomplete | None = None,
    tap_neutral: Incomplete = ...,
    tap_max: Incomplete = ...,
    tap_min: Incomplete = ...,
    tap_step_percent: Incomplete = ...,
    tap_step_degree: Incomplete = ...,
    tap_pos: Incomplete = ...,
    tap_phase_shifter: bool = False,
    in_service: bool = True,
    name: Sequence[str] | None = None,
    vector_group: Incomplete | None = None,
    index: Sequence[int] | None = None,
    max_loading_percent: Incomplete | None = None,
    parallel: int = 1,
    df: float = 1,
    vk0_percent: Incomplete | None = None,
    vkr0_percent: Incomplete | None = None,
    mag0_percent: Incomplete | None = None,
    mag0_rx: Incomplete | None = None,
    si0_hv_partial: Incomplete | None = None,
    pt_percent: Incomplete | None = None,
    oltc: Incomplete | None = None,
    tap_dependent_impedance: Incomplete | None = None,
    vk_percent_characteristic: Incomplete | None = None,
    vkr_percent_characteristic: Incomplete | None = None,
    xn_ohm: Incomplete | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_transformer3w(
    net: pandapowerNet,
    hv_bus: int,
    mv_bus: int,
    lv_bus: int,
    std_type: str,
    name: str | None = None,
    tap_pos: int = ...,
    in_service: bool = True,
    index: int | None = None,
    max_loading_percent: float = ...,
    tap_at_star_point: bool = False,
    tap_dependent_impedance: bool | None = None,
    vk_hv_percent_characteristic: int | None = None,
    vkr_hv_percent_characteristic: int | None = None,
    vk_mv_percent_characteristic: int | None = None,
    vkr_mv_percent_characteristic: int | None = None,
    vk_lv_percent_characteristic: int | None = None,
    vkr_lv_percent_characteristic: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_transformer3w_from_parameters(
    net: pandapowerNet,
    hv_bus: int,
    mv_bus: int,
    lv_bus: int,
    vn_hv_kv: float,
    vn_mv_kv: float,
    vn_lv_kv: float,
    sn_hv_mva: float,
    sn_mv_mva: float,
    sn_lv_mva: float,
    vk_hv_percent: float,
    vk_mv_percent: float,
    vk_lv_percent: float,
    vkr_hv_percent: float,
    vkr_mv_percent: float,
    vkr_lv_percent: float,
    pfe_kw: float,
    i0_percent: float,
    shift_mv_degree: float = 0,
    shift_lv_degree: float = 0,
    tap_side: Literal["hv", "mv", "lv"] | None = None,
    tap_step_percent: float = ...,
    tap_step_degree: float = ...,
    tap_pos: int = ...,
    tap_neutral: int = ...,
    tap_max: int = ...,
    tap_min: int = ...,
    name: str | None = None,
    in_service: bool = True,
    index: int | None = None,
    max_loading_percent: float = ...,
    tap_at_star_point: bool = False,
    vk0_hv_percent: float = ...,
    vk0_mv_percent: float = ...,
    vk0_lv_percent: float = ...,
    vkr0_hv_percent: float = ...,
    vkr0_mv_percent: float = ...,
    vkr0_lv_percent: float = ...,
    vector_group: str | None = None,
    tap_dependent_impedance: int | None = None,
    vk_hv_percent_characteristic: int | None = None,
    vkr_hv_percent_characteristic: int | None = None,
    vk_mv_percent_characteristic: int | None = None,
    vkr_mv_percent_characteristic: int | None = None,
    vk_lv_percent_characteristic: int | None = None,
    vkr_lv_percent_characteristic: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_transformers3w_from_parameters(
    net: pandapowerNet,
    hv_buses: Sequence[int],
    mv_buses: Sequence[int],
    lv_buses: Sequence[int],
    vn_hv_kv: float | Sequence[float],
    vn_mv_kv: float | Sequence[float],
    vn_lv_kv: float | Sequence[float],
    sn_hv_mva: float | Sequence[float],
    sn_mv_mva: float | Sequence[float],
    sn_lv_mva: float | Sequence[float],
    vk_hv_percent: float | Sequence[float],
    vk_mv_percent: float | Sequence[float],
    vk_lv_percent: float | Sequence[float],
    vkr_hv_percent: float | Sequence[float],
    vkr_mv_percent: float | Sequence[float],
    vkr_lv_percent: float | Sequence[float],
    pfe_kw: float | Sequence[float],
    i0_percent: float | Sequence[float],
    shift_mv_degree: float | Sequence[float] = 0,
    shift_lv_degree: float | Sequence[float] = 0,
    tap_side: Literal["hv", "mv", "lv"] | Sequence[Literal["hv", "mv", "lv"]] | None = None,
    tap_step_percent: float | Sequence[float] = ...,
    tap_step_degree: float | Sequence[float] = ...,
    tap_pos: int | Sequence[int] = ...,
    tap_neutral: int | Sequence[int] = ...,
    tap_max: int | Sequence[int] = ...,
    tap_min: int | Sequence[int] = ...,
    name: Sequence[str] | None = None,
    in_service: bool | Sequence[bool] = True,
    index: Sequence[int] | None = None,
    max_loading_percent: Incomplete | None = None,
    tap_at_star_point: bool = False,
    vk0_hv_percent: Incomplete = ...,
    vk0_mv_percent: Incomplete = ...,
    vk0_lv_percent: Incomplete = ...,
    vkr0_hv_percent: Incomplete = ...,
    vkr0_mv_percent: Incomplete = ...,
    vkr0_lv_percent: Incomplete = ...,
    vector_group: Incomplete | None = None,
    tap_dependent_impedance: Incomplete | None = None,
    vk_hv_percent_characteristic: Incomplete | None = None,
    vkr_hv_percent_characteristic: Incomplete | None = None,
    vk_mv_percent_characteristic: Incomplete | None = None,
    vkr_mv_percent_characteristic: Incomplete | None = None,
    vk_lv_percent_characteristic: Incomplete | None = None,
    vkr_lv_percent_characteristic: Incomplete | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_switch(
    net: pandapowerNet,
    bus: int,
    element: int,
    et: Literal["l", "t", "t3", "b"],
    closed: bool = True,
    type: Literal["LS", "CB", "LBS", "DS"] | None = None,
    name: str | None = None,
    index: int | None = None,
    z_ohm: float = 0,
    in_ka: float | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_switches(
    net: pandapowerNet,
    buses: Sequence[int],
    elements: Sequence[int],
    et: Literal["l", "t", "t3", "b"] | Sequence[Literal["l", "t", "t3", "b"]],
    closed: bool | Sequence[bool] = True,
    type: Literal["LS", "CB", "LBS", "DS"] | Sequence[Literal["LS", "CB", "LBS", "DS"]] | None = None,
    name: Sequence[str] | None = None,
    index: Sequence[int] | None = None,
    z_ohm: float | Sequence[float] = 0,
    in_ka: float | Sequence[float] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_shunt(
    net: pandapowerNet,
    bus: int,
    q_mvar: float,
    p_mw: float = 0,
    vn_kv: float | None = None,
    step: int = 1,
    max_step: int = 1,
    name: str | None = None,
    in_service: bool = True,
    index: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_shunts(
    net: pandapowerNet,
    buses: Sequence[int],
    q_mvar: float | Sequence[float],
    p_mw: float | Sequence[float] = 0,
    vn_kv: float | Sequence[float] | None = None,
    step: int | Sequence[int] = 1,
    max_step: int | Sequence[int] = 1,
    name: Sequence[str] | None = None,
    in_service: bool | Sequence[bool] = True,
    index: Sequence[int] | None = None,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_shunt_as_capacitor(net: pandapowerNet, bus: int, q_mvar: float, loss_factor: float, **kwargs: Incomplete) -> int: ...
def create_impedance(
    net: pandapowerNet,
    from_bus: int,
    to_bus: int,
    rft_pu: float,
    xft_pu: float,
    sn_mva: float,
    rtf_pu: float | None = None,
    xtf_pu: float | None = None,
    name: str | None = None,
    in_service: bool = True,
    index: int | None = None,
    rft0_pu: float | None = None,
    xft0_pu: float | None = None,
    rtf0_pu: float | None = None,
    xtf0_pu: float | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_series_reactor_as_impedance(
    net: pandapowerNet,
    from_bus: int,
    to_bus: int,
    r_ohm: float,
    x_ohm: float,
    sn_mva: float,
    name: str | None = None,
    in_service: bool = True,
    index: int | None = None,
    r0_ohm: float | None = None,
    x0_ohm: float | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_ward(
    net: pandapowerNet,
    bus: int,
    ps_mw: float,
    qs_mvar: float,
    pz_mw: float,
    qz_mvar: float,
    name: str | None = None,
    in_service: bool = True,
    index: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_xward(
    net: pandapowerNet,
    bus: int,
    ps_mw: float,
    qs_mvar: float,
    pz_mw: float,
    qz_mvar: float,
    r_ohm: float,
    x_ohm: float,
    vm_pu: float,
    in_service: bool = True,
    name: str | None = None,
    index: int | None = None,
    slack_weight: float = 0,
    **kwargs: Incomplete,
) -> int: ...
def create_dcline(
    net: pandapowerNet,
    from_bus: int,
    to_bus: int,
    p_mw: float,
    loss_percent: float,
    loss_mw: float,
    vm_from_pu: float,
    vm_to_pu: float,
    index: int | None = None,
    name: str | None = None,
    max_p_mw: float = ...,
    min_q_from_mvar: float = ...,
    min_q_to_mvar: float = ...,
    max_q_from_mvar: float = ...,
    max_q_to_mvar: float = ...,
    in_service: bool = True,
    **kwargs: Incomplete,
) -> int: ...
def create_measurement(
    net: pandapowerNet,
    meas_type: Literal["v", "p", "q", "i", "va", "ia"],
    element_type: Literal["bus", "line", "trafo", "trafo3w"],
    value: float,
    std_dev: float,
    element: int,
    side: Literal["hv", "mv", "lv"] | int | None = None,
    check_existing: bool = True,
    index: int | None = None,
    name: str | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_pwl_cost(
    net: pandapowerNet,
    element: int,
    et: Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"],
    points: Sequence[Incomplete],
    power_type: Literal["p", "q"] = "p",
    index: int | None = None,
    check: bool = True,
    **kwargs: Incomplete,
) -> int: ...
def create_pwl_costs(
    net: pandapowerNet,
    elements: Sequence[int],
    et: Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"]
    | Sequence[Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"]],
    points: Sequence[Sequence[Incomplete]],
    power_type: Literal["p", "q"] | Sequence[Literal["p", "q"]] = "p",
    index: Sequence[int] | None = None,
    check: bool | Sequence[bool] = True,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_poly_cost(
    net: pandapowerNet,
    element: int,
    et: Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"],
    cp1_eur_per_mw: float,
    cp0_eur: float = 0,
    cq1_eur_per_mvar: float = 0,
    cq0_eur: float = 0,
    cp2_eur_per_mw2: float = 0,
    cq2_eur_per_mvar2: float = 0,
    index: int | None = None,
    check: bool = True,
    **kwargs: Incomplete,
) -> int: ...
def create_poly_costs(
    net: pandapowerNet,
    elements: Sequence[int],
    et: Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"]
    | Sequence[Literal["gen", "sgen", "ext_grid", "load", "dcline", "storage"]],
    cp1_eur_per_mw: float | Sequence[float],
    cp0_eur: float | Sequence[float] = 0,
    cq1_eur_per_mvar: float | Sequence[float] = 0,
    cq0_eur: float | Sequence[float] = 0,
    cp2_eur_per_mw2: float | Sequence[float] = 0,
    cq2_eur_per_mvar2: float | Sequence[float] = 0,
    index: Sequence[int] | None = None,
    check: bool | Sequence[bool] = True,
    **kwargs: Incomplete,
) -> NDArray[np.int_]: ...
def create_group(
    net: pandapowerNet,
    element_types: str | Sequence[str],
    elements: Sequence[Sequence[Incomplete]],
    name: str = "",
    reference_columns: str | Sequence[str] | None = None,
    index: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
def create_group_from_dict(
    net: pandapowerNet,
    elements_dict: Mapping[str, Sequence[Incomplete]],
    name: str = "",
    reference_column: Incomplete | None = None,
    index: int | None = None,
    **kwargs: Incomplete,
) -> int: ...
